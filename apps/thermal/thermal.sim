element Point
  xy    : vector[2](float);
end

element Quad
  T  : float;
  K  : float;
  rho: float;
  cv : float;
  dxy: vector[2](float);
  gamma: float;
end

element Face
  dir    : int;
  Khalf  : float;
  dxyhalf: float;
end

element BoundCond
  qw : float;
end

extern points   : set{Point};
extern quads    : set{Quad}(points,points,points,points);
extern faces    : set{Face}(quads,quads);
extern bcleft   : set{BoundCond}(quads);
extern bcright  : set{BoundCond}(quads);
extern bcup     : set{BoundCond}(quads);
extern bcbottom : set{BoundCond}(quads);

extern iter : vector[2](int);
extern iterMax_coupling : vector[2](int);
extern dt : vector[2](float);
extern cfl : vector[2](float);
extern tolerance_coupling : vector[2](float);


%%%%%%%%%%%%%%% Future Intrinsics Functions %%%%%%%%%%%%%%%%%%
func eye(q:Quad)->I:matrix[quads,quads](float)
    I(q,q)=1.0;
end

%%%%%%%%%%%%%%%%% Print Functions %%%%%%%%%%%%%%%%%%%%%%%
func printPoints()
    for p in points
        print p.xy(0), " ", p.xy(1), "\n";
    end
    print "\n";
end

func printb(b:vector[quads](float))
    print " b = \n";
    for q in quads
        print b(q), "\n";
    end
    print "\n";
end

%%%%%%%%%%%%%%%% Thermal Solve %%%%%%%%%%%%%%%%%%%%%

func boundary_conditions(dir:int,dt:float,bc:BoundCond,q:(Quad*1))->b:vector[quads](float)
    % dir : 0 if x , 1 if y
    b(q(0))=(bc.qw*dt)/(q(0).rho*q(0).cv*q(0).dxy(dir));
end

func assemble_diffusion(f:Face,q:(Quad*2))->A:matrix[quads,quads](float)
    A(q(0),q(0))=(q(0).gamma*f.Khalf)/(q(0).dxy(f.dir)*f.dxyhalf);
    A(q(1),q(1))=(q(1).gamma*f.Khalf)/(q(1).dxy(f.dir)*f.dxyhalf);
    A(q(0),q(1))=-(f.Khalf*q(0).gamma)/(f.dxyhalf*q(0).dxy(f.dir));
    A(q(1),q(0))=-(f.Khalf*q(1).gamma)/(f.dxyhalf*q(1).dxy(f.dir));
end

export func solve_thermal()
%% Problem : A(Tn+1 -Tn)=Tn - ATn + BC

    % compute second member by adding boundary conditions
    % b:vector[quads](float) = Tn + BC
    var b:vector[quads](float);
    b = map boundary_conditions(0,dt(0)) to bcright reduce +;
    b = b + (map boundary_conditions(0,dt(0)) to bcleft reduce +);
    b = b + (map boundary_conditions(1,dt(0)) to bcup reduce +);
    b = b + (map boundary_conditions(1,dt(0)) to bcbottom reduce +);
    b = b + quads.T;

    % assemble matrix A
    %var A : matrix[quads,quads](float);
    var A = map assemble_diffusion to faces reduce +;
    %I = map eye to quads reduce +;
    for q in quads
        A(q,q) = A(q,q) + 1.0;
    end
    b = b - A*quads.T;

    % solve and find Tn+1
    solver = lu(A);
    TNN = lusolve<quads,quads>(solver, b);
    lufree(solver);
    quads.T=TNN+quads.T;
    
end


%%%%%%%%%%%%%%%%  Compute TimeStep %%%%%%%%%%%%%%%%%%%%

func compute_dxy(inout q:Quad,p:(Point*4))
    q.dxy(0)=max(abs(p(1).xy(0)-p(0).xy(0)),abs(p(2).xy(0)-p(3).xy(0)));
    q.dxy(1)=max(abs(p(3).xy(1)-p(0).xy(1)),abs(p(2).xy(1)-p(1).xy(1)));
end

func compute_halfValues(inout f:Face,q:(Quad*2))
    f.Khalf   = (q(0).K+q(1).K)/2.0;
    f.dxyhalf = (q(0).dxy(f.dir)+q(1).dxy(f.dir))/2.0;
end

func compute_coeff(q:Quad, p:(Point*4))-> c:vector[quads](float)
    % coeff = 2*K/(rho*cv*(max(dx²,dy²)))
    dxy2 = q.dxy.*q.dxy;
    c(q) = 2.0*q.K / (q.rho*q.cv*max(dxy2(0),dxy2(1)));
end

export func compute_dt()
    % start by computing all delta_x and delta_y for each quad
    apply compute_dxy to quads;
    
    % dt = cfl / max( 2*K/(rho*cv*(max(dx²,dy²))) )
    coeff_dt = map compute_coeff to quads reduce +;
    var m=0.0;
    for q in quads
        if coeff_dt(q) >= m
            m = coeff_dt(q);
        end
    end
    dt(0) = cfl(0) / m;

    % print " dt = ", dt(0), "\n";

    % compute gamma to quads;
    quads.gamma=dt(0)/(quads.rho.*quads.cv);
    apply compute_halfValues to faces;
end